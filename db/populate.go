package db

import (
	"bufio"
	"database/sql"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/kopolindo/cve-scraper/cwe"
	"github.com/kopolindo/cve-scraper/mitre"
	"github.com/kopolindo/cve-scraper/nvd"
	_ "github.com/mattn/go-sqlite3"
	pb "gopkg.in/cheggaaa/pb.v1"
)

type Results struct {
	Cve      string //cve.cve
	CveDesc  string //cve.cve_description
	Cwe      string //cve.cwe
	CweDesc  string //cve.cwe_description
	Exploit  int    //cve.exploit
	Refs     string //cve.refs
	Cvssv2   string //cve.cvssv2
	Cvssv3   string //cve.cvssv3
	Software string //sw.software
	Version  string //sw.version
}

type Fields struct {
	id, cveID, cveDescription, cwe, cweDescription, refs, cvssv2, cvssv3, sw, ver string
	exploit                                                                       int
}

//STRUCT TO UNMARSHAL JSONS CRAWLWD FRON NIST NVD
type CveRecord struct {
	Id, Description, Refs, Cvssv2, Cvssv2score string
}

var (
	completeListNVD   = "./.sources/nvd/nvdcve-1.0-YEAR.json"
	completeListMITRE = "./.sources/mitre/allitems.xml"
	database          = ".local/vuln_db"
	jsonDir2Import    = "./jsons/"
	dbUrl             = "https://github.com/kopolindo/cve-scraper/releases/download/1.0/vuln_db"
)

func OpenDB() *sql.DB {
	//Check Database File existence
	if _, err := os.Stat(database); err != nil {
		fmt.Println("Database file doesn't exist\nDo you want to download it from the current release? [Y/n]")
		reader := bufio.NewReader(os.Stdin)
		response, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println("ERROR: reading from Stdin", err)
			os.Exit(1)
		}
		if response != "Y\n" && response != "n\n" {
			fmt.Println("INFO: wrong choice")
			os.Exit(1)
		}
		if response == "n\n" {
			fmt.Println("Exiting")
			os.Exit(0)
		}
		if response == "Y\n" {
			dbFile, err := os.Create(database)
			if err != nil {
				fmt.Println("ERROR: cannot create database file", err)
				os.Exit(1)
			}
			defer dbFile.Close()
			response, err := http.Get(dbUrl)
			if err != nil {
				fmt.Println("ERROR: downloading database", err)
			}
			defer response.Body.Close()
			bar := pb.New(179113984).SetUnits(pb.U_BYTES)
			bar.Start()
			rd := bar.NewProxyReader(response.Body)
			_, err = io.Copy(dbFile, rd)
			bar.Finish()
			if err != nil {
				fmt.Println("ERROR: cannot fetch response into database file", err)
			}
		}
	}
	//Open db file
	cveDB, err_opening := sql.Open("sqlite3", database)
	if err_opening != nil {
		fmt.Println("Opening error:")
		panic(err_opening)
	}
	return cveDB
}

func UnmarshalNIST() []CveRecord {
	var cve CveRecord
	var out []CveRecord
	_panic := func(err error) {
		if err != nil {
			panic(err)
		}
	}
	files, err := ioutil.ReadDir(jsonDir2Import)
	_panic(err)
	for _, f := range files {
		fullpath := strings.Join([]string{"./jsons", f.Name()}, "/")
		//fmt.Println(fullpath)
		if _, err := os.Stat(strings.Join([]string{"./jsons", f.Name()}, "/")); err != nil {
			fmt.Println("List file doesn't exist")
		}
		f, err := os.Open(fullpath)
		_panic(err)
		d := json.NewDecoder(f)
		err = d.Decode(&cve)
		_panic(err)
		out = append(out, cve)
		f.Close()
	}
	return out
}

func UnmarshalMITRE() {
	_panic := func(err error) {
		if err != nil {
			panic(err)
		}
	}
	if _, err := os.Stat(completeListMITRE); err != nil {
		fmt.Println("Database file doesn't exist")
	}
	f, err := os.Open(completeListMITRE)
	_panic(err)
	d := xml.NewDecoder(f)
	var cveMitre mitre.Cve
	err = d.Decode(&cveMitre)
	_panic(err)
	for _, cve := range cveMitre.Item {
		fmt.Println(cve.Name, " DESCRIPTION: ", cve.Desc)
		//fmt.Println("REFERENCES :", cve.Refs)
	}
}

func Insert(cveDB *sql.DB, params []string) {
	//Insert query
	switch l := len(params); l {
	case 3:
		querySw, _ := cveDB.Prepare("INSERT OR IGNORE INTO sw (id,software,version) VALUES (?, ?, ?)")
		querySw.Exec(params[0], params[1], params[2])
	case 5:
		queryCve, _ := cveDB.Prepare("INSERT OR IGNORE INTO cve (id, cve,cve_description,refs,cvssv2) VALUES (?, ?, ?, ?, ?)")
		queryCve.Exec(params[0], params[1], params[2], params[3], params[4])
	case 7:
		queryCve, _ := cveDB.Prepare("INSERT OR IGNORE INTO cve (id,cve_description,cwe,cwe_description,refs,cvssv2,cvssv3) VALUES (?, ?, ?, ?, ?, ?, ?)")
		queryCve.Exec(params[0], params[1], params[2], params[3], params[4], params[5], params[6])
	}
}

func CveSearch(cve string) (Results, int) {
	var (
		out   Results
		count int = 0
		field Fields
	)
	db := OpenDB()
	// query
	rows, err := db.Query("SELECT cve.cve,cve.cve_description,cve.cwe,cve.cwe_description,cve.refs,cve.cvssv2,cve.cvssv3,sw.software,sw.version FROM cve join sw on cve.cve = sw.id where cve.id = ? order by cve.cve desc", cve)
	if err != nil {
		fmt.Println("SQLite ERROR during \"Execution\" process: ", err)
	}
	defer rows.Close()
	//fmt.Printf("%#v", rows)
	for rows.Next() {
		count++
		err = rows.Scan(&field.cveID, &field.cveDescription, &field.cwe, &field.cweDescription, &field.refs, &field.cvssv2, &field.cvssv3, &field.sw, &field.ver)
		if err != nil {
			fmt.Println("ROW SCANNING ERROR: ", err)
		}
		out.Cve = field.cveID
		out.CveDesc = field.cveDescription
		out.Cwe = field.cwe
		out.CweDesc = field.cweDescription
		out.Refs = field.refs
		out.Cvssv2 = field.cvssv2
		out.Cvssv3 = field.cvssv3
		out.Software = field.sw
		out.Version = field.ver
	}
	if rows.Err() != nil {
		fmt.Println(rows.Err())
	}
	return out, count
}

func SwSearch(sw string) []Results {
	var (
		field    Fields
		outArray []Results
		out      Results
	)
	db := OpenDB()
	// query
	rows, err := db.Query(`SELECT cve.cve,cve.cve_description,sw.software,sw.version,cve.cwe,cve.cwe_description,cve.cvssv2,cve.cvssv3 FROM cve join sw on cve.cve = sw.id where sw.software like ? order by cve.cve desc`, strings.Join([]string{"%", sw, "%"}, ""))
	if err != nil {
		fmt.Println("SQLite ERROR during \"Execution\" process: ", err)
	}
	defer rows.Close()
	i := 0
	for rows.Next() {
		i++
		err := rows.Scan(&field.cveID, &field.cveDescription, &field.sw, &field.ver, &field.cwe, &field.cweDescription, &field.cvssv2, &field.cvssv3)
		if err != nil {
			fmt.Println("ROW SCANNING ERROR: ", err)
		}
		out.Cve = field.cveID
		out.CveDesc = field.cveDescription
		out.Software = field.sw
		out.Version = field.ver
		out.Cwe = field.cwe
		out.CweDesc = field.cweDescription
		out.Cvssv2 = field.cvssv2
		out.Cvssv3 = field.cvssv3
		out.Software = field.sw
		out.Version = field.ver
		outArray = append(outArray, out)
	}
	return outArray
}

func SwVSearch(sw string, ver string) []Results {
	var query string
	query = "SELECT cve.cve,cve.cve_description,sw.software,sw.version,cve.cwe,cve.cwe_description,cve.cvssv3 FROM cve join sw on cve.cve = sw.id where sw.software like ? and (sw.version like ?) order by cve.cve desc"
	software := strings.Join([]string{"%", sw, "%"}, "")
	var version, searchCase string
	db := OpenDB()
	var (
		field    Fields
		out      Results
		outArray []Results
	)
	switch first := ver[0:1]; first {
	case "~":
		searchCase = "g"
		version = strings.Join([]string{"%", ver[1:], "%"}, "")
		break
	case "+":
		searchCase = "gt"
		version = strings.Join([]string{"%|", ver[1:], ".%"}, "")
		break
	case "-":
		searchCase = "lt"
		version = strings.Join([]string{"%|", ver[1:], "%"}, "")
		break
	default:
		searchCase = "e"
		if strings.ContainsAny(ver, "xX") {
			ver = strings.Replace(ver, "x", "_", -1)
			ver = strings.Replace(ver, "X", "_", -1)
		}
		version = strings.Join([]string{"%", ver, "%"}, "")
		break
	}

	rows, err := db.Query(query, software, version)
	if err != nil {
		fmt.Println("SQLite ERROR during \"Execution\" process: ", err)
	}
	defer rows.Close()
	i := 0
	//fmt.Println(searchCase)
	_ = searchCase
	for rows.Next() {
		i++
		err := rows.Scan(&field.cveID, &field.cveDescription, &field.sw, &field.ver, &field.cwe, &field.cweDescription, &field.cvssv3)
		if err != nil {
			fmt.Println("ROW SCANNING ERROR: ", err)
		}
		if searchCase == "gt" {
			var k int
			versions := strings.Split(field.ver, "|")
			//spew.Dump(versions)
			versionLength := len(ver[1:])
			for i, v := range versions {
				if string(v[0:versionLength]) == ver[1:] {
					fmt.Println("FOUND", v, string(v[0:versionLength]), "=", ver[1:])
					k = i
					break
				}
			}
			if len(versions[1]) == 0 {
				fmt.Println("There is no version newer then ", ver)
			}
			if len(versions[1]) != 0 {
				fmt.Println("Versions newer then ", ver, "are", versions[k:])
			}
		}
		if searchCase == "e" {
			i := 0
			versions := strings.Split(field.ver, "|")
			for _, v := range versions {
				if string(ver[0]) == string(v[0]) && i < 1 {
					i++
					out.Cve = field.cveID
					out.CveDesc = field.cveDescription
					out.Software = field.sw
					out.Version = field.ver
					out.Cwe = field.cwe
					out.CweDesc = field.cweDescription
					out.Cvssv2 = field.cvssv2
					out.Cvssv3 = field.cvssv3
					out.Software = field.sw
					out.Version = field.ver
				}
			}
			outArray = append(outArray, out)
		}
		if searchCase == "g" {
			out.Cve = field.cveID
			out.CveDesc = field.cveDescription
			out.Software = field.sw
			out.Version = field.ver
			out.Cwe = field.cwe
			out.CweDesc = field.cweDescription
			out.Cvssv2 = field.cvssv2
			out.Cvssv3 = field.cvssv3
			out.Software = field.sw
			out.Version = field.ver
			outArray = append(outArray, out)
		}
	}
	return outArray
}

func UpdateTable() {
	var cve string
	var updateID []string
	var updateCVE []string
	db := OpenDB()
	// query
	rows, err := db.Query("SELECT cve FROM cve where id is null")
	if err != nil {
		fmt.Println("SQLite ERROR during \"Execution\" process: ", err)
	}
	defer rows.Close()
	for rows.Next() {
		err := rows.Scan(&cve)
		if err != nil {
			fmt.Println("ROW SCANNING ERROR: ", err)
		}
		idString := strings.Split(cve, "-")
		id, _ := strconv.Atoi(idString[2])
		idNum := strconv.Itoa(id)
		out := strings.Join([]string{"CVE", idString[1], idNum}, "-")
		updateID = append(updateID, out)
		updateCVE = append(updateCVE, cve)
		//fmt.Println(cve, " --> ", out)
	}
	for i, _ := range updateID {
		insertQ, err := db.Prepare("UPDATE or ignore cve SET id = ? WHERE cve.cve = ?")
		insertQ.Exec(updateID[i], updateCVE[i])
		if err != nil {
			fmt.Println("ERROR UPDATING ", err)
		}
	}
	if rows.Err() != nil {
		fmt.Println(rows.Err())
	}
}

func Populate() {
	//Check Database File existence
	if _, err := os.Stat(database); err != nil {
		fmt.Println("Database file doesn't exist")
	}
	//Open db file
	cveDB, err_opening := sql.Open("sqlite3", database)
	if err_opening != nil {
		fmt.Println("Opening error:")
		panic(err_opening)
	}
	//Assign to cweList the complete list of weaknesses
	cweList := cwe.Load()
	//Declaration
	for i := 2002; i < 2019; i++ {
		var complete nvd.RootComplete
		json_ := strings.Replace(completeListNVD, "YEAR", strconv.Itoa(i), -1)
		fmt.Println("PROCESSING ", json_)
		completeContent, _ := ioutil.ReadFile(json_)
		unm_err_c := json.Unmarshal(completeContent, &complete)
		if unm_err_c != nil {
			panic(unm_err_c)
		}
		cveArray := complete.CVEItems
		//Testo tramite print :S (complete list)
		for _, cve := range cveArray {
			//ID
			ID := cve.CVE.CVEDataMeta.ID
			//CVSSv2 Vector
			CvssV2Vector := cve.Impact.BaseV2.CVSSv2.VectorString
			//CVSSv3 Vector
			CvssV3Vector := cve.Impact.BaseV3.CVSSv3.VectorString
			//CVE Description
			CveDescription := cve.CVE.Description.DescriptionData

			//DESCRIPTION
			tmpDescArray := []string{}
			for _, cvedesc := range CveDescription {
				tmpDescArray = append(tmpDescArray, cvedesc.Value)
			}
			cveDescArray := strings.Join(tmpDescArray, "|")

			//REFERENCES
			tmpRefArray := []string{}
			References := cve.CVE.References.ReferenceData
			for _, refs := range References {
				tmpRefArray = append(tmpRefArray, refs.Url)
			}
			cveRefArray := strings.Join(tmpRefArray, "|")
			//PROBLEMTYPE
			tmpCWEArray := []string{}
			tmpCWEDescArray := []string{}
			problemType := cve.CVE.Problemtype.ProblemtypeData
			for _, problem := range problemType {
				for _, desc := range problem.Description {
					tmpCWEArray = append(tmpCWEArray, desc.Value)
					tmpCWEDescArray = append(tmpCWEDescArray, cweList[desc.Value])
				}
			}
			cveCWEArray := strings.Join(tmpCWEArray, "|")
			cveCWEDescArray := strings.Join(tmpCWEDescArray, "|")

			/******************
			*		SOFTWARE		*
			******************/
			var vendorData = cve.CVE.Affects.Vendor.VendorData
			for _, software := range vendorData {
				var product = software.Product.ProductData
				//PER OGNI VENDOR PRENDO LA LISTA DEI SW
				for _, sw := range product {
					//PER OGNI SW PRENDO LA LISTA DELLE VERSIONI
					tmpVersionArray := []string{}
					for _, ver := range sw.Version.VersionData {
						tmpVersionArray = append(tmpVersionArray, ver.VersionValue)
					}
					verArray := strings.Join(tmpVersionArray, "|")
					swInsertParams := [3]string{ID, sw.ProductName, verArray}
					Insert(cveDB, swInsertParams[:])
				}
			}
			cveInsertParams := [7]string{ID, cveDescArray, cveCWEArray, cveCWEDescArray, cveRefArray, CvssV2Vector, CvssV3Vector}
			Insert(cveDB, cveInsertParams[:])
		}
		fmt.Println("END PROCESSING ", json_)
	}

	_ = cveDB.Close()
}
