package crawl

import (
	"bufio"
	"bytes"
	"fmt"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/empijei/cli/lg"
	"golang.org/x/net/html"
)

type CveRecord struct {
	Id, Description, Refs, Cvssv2, Cvssv2score string
}

var linkCount = make(chan struct{}, 10)
var pageCount = make(chan struct{}, 10)
var errorCount = make(chan struct{}, 10)

func perfMon() {
	start := time.Now()
	var processedPages, linkExtracted, errors int
	for {
		select {
		case <-linkCount:
			linkExtracted++
		case <-pageCount:
			processedPages++
		case <-errorCount:
			errors++
		}
		fmt.Printf("\rPages: %d Links: %d Pages per second: %3.2f Errors:%d       ", processedPages, linkExtracted, float64(processedPages)/float64(time.Now().Sub(start).Seconds()), errors)
	}
}

// Crawl will start crawling asynchronously and will write every found record in the returned channel
func Crawl() <-chan CveRecord {

	go perfMon()

	months := make(chan string, 100)
	cvePages := make(chan string, 10000)
	cveRecords := make(chan CveRecord, 10000)

	linkfile, err := os.Open("./crawl/linkfile.txt")
	if err != nil {
		lg.Debug("Linkfile not found, crawling from scratch")
		go parseRoot(months)
		go parseCveList(cvePages, months)
	} else {
		lg.Debug("Linkfile found... reading")
		go func() {
			s := bufio.NewScanner(linkfile)
			for s.Scan() {
				cvePages <- s.Text()
			}
			_ = linkfile.Close()
		}()
	}

	parseCvePage(cveRecords, cvePages)

	return cveRecords
}

func parseRoot(links chan<- string) {
	getLinks("https://nvd.nist.gov/vuln/full-listing", func(link string) bool {
		return strings.HasPrefix(link, "/vuln/full-listing/19") ||
			strings.HasPrefix(link, "/vuln/full-listing/2000") ||
			strings.HasPrefix(link, "/vuln/full-listing/2001")
	}, links)
	close(links)
}

func parseCveList(cvePages chan<- string, months <-chan string) {
	f, err := os.OpenFile("linkfile.txt", os.O_RDWR|os.O_CREATE, 0755)
	if err != nil {
		lg.Failure(err)
	}
	defer func() { _ = f.Close() }()
	buf := make(chan string, len(cvePages))
	go func() {
		for url := range buf {
			cvePages <- url
			_, _ = f.WriteString(url)
			_, _ = f.WriteString("\n")
		}
		close(cvePages)
	}()
	for month := range months {
		url := "https://nvd.nist.gov" + month
		getLinks(url, func(cveurl string) bool {
			return strings.HasPrefix(cveurl, "/vuln/detail/CVE-")
		}, buf)
	}
	close(buf)
}

var throttle sync.WaitGroup

func waitForThrottling() {
	throttle.Wait()
}

// Stacca stacca stacca ci stanno tracciando
func throttleDetected() {
	throttle.Add(1)
	time.AfterFunc(15*time.Second, func() { throttle.Done() })
}

func parseCvePage(cveRecords chan<- CveRecord, cvePages <-chan string) {
	defer close(cveRecords)
	poolsize := 4
	var wg sync.WaitGroup
	lg.Debugf("Now spawning %d workers", poolsize)
	wg.Add(poolsize)
	for i := 0; i < poolsize; i++ {
		go func() {
			//for cveurl := range cvePages {
			var cveurl string
			okp, okr := true, true
			cveRecoveredPages := make(chan string, 1000000)
			for {
				select {
				case cveurl, okp = <-cvePages:
					if !okp {
						continue
					}
				case cveurl, okr = <-cveRecoveredPages:
					if !okp && len(cveRecoveredPages) == 0 {
						//this probably panics, FIXME
						//close(cveRecoveredPages)
						lg.Debug("Should be done")
					}
				}
				if !okr && !okp {
					break
				}
				var cve CveRecord
				url := "https://nvd.nist.gov" + cveurl
				//lg.Debug("Now processing page: ", url)
				urlparts := strings.Split(url, "/")
				cve.Id = urlparts[len(urlparts)-1]

				cve.Refs = url

				waitForThrottling()
				resp, err := http.Get(url)
				if err != nil {
					lg.Error(err)
					cveRecoveredPages <- cveurl
					errorCount <- struct{}{}
					throttleDetected()
					continue
				}
				tkn := html.NewTokenizer(resp.Body)

				foundInfo := 0
				iterations := 0
				//iterations are at most 800, 1000 was chosen as a maximum possible amount acceptable
				for foundInfo < 3 && iterations < 1000 {
					iterations++
					tok := tkn.Next()
					switch tok {
					case html.ErrorToken:
						continue
					case html.StartTagToken, html.EndTagToken:
						tn, _ := tkn.TagName()
						// handle description
						if len(tn) == 1 && tn[0] == 'p' {
							more := true
							var key, value []byte
							for more {
								key, value, more = tkn.TagAttr()
								if string(key) == "data-testid" && string(value) == "vuln-description" {
									tkn.Next()
									cve.Description = string(tkn.Text())
									foundInfo++
									break
								}
							}
						}
						// handle CVSS
						if len(tn) == 1 && tn[0] == 'a' {
							more := true
							var key, value []byte
							for more && foundInfo < 3 {
								key, value, more = tkn.TagAttr()
								if string(key) == "data-testid" {
									// handle CVSS vector
									if string(value) == "vuln-cvssv2-vector-link" {
										tkn.Next()
										cve.Cvssv2 = string(bytes.Trim(bytes.TrimSpace(tkn.Text()), "()"))
										foundInfo++
										break
									}
									// handle CVSS score
									if string(value) == "vuln-cvssv2-base-score-link" {
										tkn.Next()
										cve.Cvssv2score = string(bytes.TrimSpace(tkn.Text()))
										foundInfo++
										break
									}
								}
							}
						}
					}
				}
				_ = resp.Body.Close()
				if cve.Description != "" {
					cveRecords <- cve
					pageCount <- struct{}{}
				} else {
					//lg.Error("Failed to analyze ", cve.Id)
					cveRecoveredPages <- cveurl
					throttleDetected()
					errorCount <- struct{}{}
				}
			}
			wg.Done()
		}()
	}
	wg.Wait()
}

func getLinks(url string, filter func(url string) (shouldAppend bool), out chan<- string) {
	resp, err := http.Get(url)
	if err != nil {
		lg.Error(err)
		errorCount <- struct{}{}
		return
	}
	tkn := html.NewTokenizer(resp.Body)
	for {
		tok := tkn.Next()
		switch tok {
		case html.ErrorToken:
			return
		case html.StartTagToken, html.EndTagToken:
			tn, _ := tkn.TagName()
			if len(tn) == 1 && tn[0] == 'a' {
				more := true
				var key, value []byte
				for more {
					key, value, more = tkn.TagAttr()
					if string(key) == "href" {
						if filter(string(value)) {
							linkCount <- struct{}{}
							out <- string(value)
						}
						break
					}
				}
			}
		}
	}
}
