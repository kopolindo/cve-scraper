package main

import (
	"database/sql"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"./cwe"
	"./db"
	"./nvd"
	_ "github.com/mattn/go-sqlite3"
)

var completeList = "./.sources/nvd/nvdcve-1.0-YEAR.json"
var database = ".local/vuln_db"

func main() {
	//Check Database File existence
	if _, err := os.Stat(database); err != nil {
		fmt.Println("Database file doesn't exist")
	}
	//Open db file
	cveDB, err_opening := sql.Open("sqlite3", database)
	if err_opening != nil {
		fmt.Println("ERRORE IN FASE DI APERTURA:")
		panic(err_opening)
	}
	//Assign to cweList the complete list of weaknesses
	cweList := cwe.Load()
	//Declaration
	for i := 2002; i < 2019; i++ {
		var complete nvd.RootComplete
		json := strings.Replace(completeList, "YEAR", strconv.Itoa(i), -1)
		fmt.Println("PROCESSING ", json)
		completeContent, _ := ioutil.ReadFile(json)
		unm_err_c := json.Unmarshal(completeContent, &complete)
		if unm_err_c != nil {
			panic(unm_err_c)
		}
		cveArray := complete.CVEItems
		//Testo tramite print :S (complete list)
		for _, cve := range cveArray {
			//ID
			ID := cve.CVE.CVEDataMeta.ID
			//CVSSv2 Vector
			CvssV2Vector := cve.Impact.BaseV2.CVSSv2.VectorString
			//CVSSv3 Vector
			CvssV3Vector := cve.Impact.BaseV3.CVSSv3.VectorString
			//CVE Description
			CveDescription := cve.CVE.Description.DescriptionData

			//DESCRIPTION
			tmpDescArray := []string{}
			for _, cvedesc := range CveDescription {
				tmpDescArray = append(tmpDescArray, cvedesc.Value)
			}
			cveDescArray := strings.Join(tmpDescArray, "|")

			//REFERENCES
			tmpRefArray := []string{}
			References := cve.CVE.References.ReferenceData
			for _, refs := range References {
				tmpRefArray = append(tmpRefArray, refs.Url)
			}
			cveRefArray := strings.Join(tmpRefArray, "|")
			//PROBLEMTYPE
			tmpCWEArray := []string{}
			tmpCWEDescArray := []string{}
			problemType := cve.CVE.Problemtype.ProblemtypeData
			for _, problem := range problemType {
				for _, desc := range problem.Description {
					tmpCWEArray = append(tmpCWEArray, desc.Value)
					tmpCWEDescArray = append(tmpCWEDescArray, cweList[desc.Value])
				}
			}
			cveCWEArray := strings.Join(tmpCWEArray, "|")
			cveCWEDescArray := strings.Join(tmpCWEDescArray, "|")

			/******************
			*		SOFTWARE		*
			******************/
			var vendorData = cve.CVE.Affects.Vendor.VendorData
			for _, software := range vendorData {
				var product = software.Product.ProductData
				//PER OGNI VENDOR PRENDO LA LISTA DEI SW
				for _, sw := range product {
					//fmt.Println("\tSoftware(", i, ": ", sw.ProductName)
					//PER OGNI SW PRENDO LA LISTA DELLE VERSIONI
					tmpVersionArray := []string{}
					for _, ver := range sw.Version.VersionData {
						//fmt.Println("\tVersion:", ver.VersionValue)
						tmpVersionArray = append(tmpVersionArray, ver.VersionValue)
					}
					verArray := strings.Join(tmpVersionArray, "|")
					//fmt.Println("SOFTWARE: ", sw.ProductName, "VERSIONS: ", verArray)
					swInsertParams := [3]string{ID, sw.ProductName, verArray}
					db.Insert(cveDB, swInsertParams[:])
				}
			}
			//fmt.Println(ID, ",", cveDescArray, ",", cveCWEArray, ",", cveCWEDescArray, ",", cveRefArray, ",", CvssV2Vector, ",", CvssV3Vector)
			cveInsertParams := [7]string{ID, cveDescArray, cveCWEArray, cveCWEDescArray, cveRefArray, CvssV2Vector, CvssV3Vector}
			db.Insert(cveDB, cveInsertParams[:])
		}
		fmt.Println("END PROCESSING ", json)
	}
	cveDB.Close()
}
