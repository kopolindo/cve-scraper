package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"regexp"
	"strings"
	"text/tabwriter"

	"github.com/alecthomas/template"
	"github.com/jweir/csv"
	"github.com/kopolindo/cve-scraper/db"
	_ "github.com/mattn/go-sqlite3"
)

const banner = `
                                                                            
 ####  #    # ######        ####   ####  #####    ##   #####  ###### #####  
#    # #    # #            #      #    # #    #  #  #  #    # #      #    # 
#      #    # #####  #####  ####  #      #    # #    # #    # #####  #    # 
#      #    # #                 # #      #####  ###### #####  #      #####  
#    #  #  #  #            #    # #    # #   #  #    # #      #      #   #  
 ####    ##   ######        ####   ####  #    # #    # #      ###### #    #   
 
 |Version: {{.Ver}}
 |Commit:  {{.Commit}}
 |Build:   {{.Build}}

`

type Version struct {
	Ver    string
	Build  string
	Commit string
}

var (
	fieldsToPrint []string
	AllowedFields = []string{"Cve", "CveDesc", "Cwe", "CweDesc", "Exploit", "Refs", "Cvssv2", "Cvssv3", "Software", "Version"}

	ActualVersion = Version{"0.1", "Developing", "de9bd41fa1450f6a5bbb667567040615c945c0c6"}
	output        bool
)

//FLAGS
var (
	cve       = flag.String("cve", "", "CVE-ID to look for (at least year in format YYYY and ID number)")
	sw        = flag.String("sw", "", "Software name to look for")
	swVersion = flag.String("swv", "", "Software version (Exact search by default)\n\t~ Generic search (looks for any similar string in the version field)")
	fields    = flag.String("fields", "", "Fields to print, comma separated\n[Cve,CveDesc,Cwe,CweDesc,Exploit,Refs,Cvssv2,Cvssv3,Software,Version]")
	write     = flag.String("write", "", "Output file (csv)")
	header    = flag.Bool("header", false, "Print header: false by default. If CSV output desired header is true by default")
	version   = flag.Bool("version", false, "Print version and exit")
)

func printbanner() {
	tmpl := template.New("banner")
	template.Must(tmpl.Parse(banner))
	_ = tmpl.Execute(os.Stderr, ActualVersion)
}

func Usage() {
	printbanner()
	fmt.Println("\nUsage flags:")
	flag.PrintDefaults()
	return
}

func Init() {
	flag.Parse()
	if flag.NFlag() == 0 {
		Usage()
		os.Exit(0)
	}
	if *version {
		printbanner()
	}
	if *fields != "" {
		if *fields != "help" {
			fieldsToPrint = validateFields()
		}
		if *fields == "help" {
			fmt.Println("Cve\t\tCVE Identification (CVE-YYYY-ID)")
			fmt.Println("CveDesc\t\tVulnerability Description")
			fmt.Println("Cwe\t\tCommon Weakness Enumeration ID")
			fmt.Println("CweDesc\t\tCWE Description (type of vulnerability)")
			fmt.Println("Exploit\t\tExistence of known exploits")
			fmt.Println("Refs\t\tReferences")
			fmt.Println("Cvssv2\t\tCommon Vulnerability Scoring System Vector (v2)")
			fmt.Println("Cvssv3\t\tCommon Vulnerability Scoring System Vector (v3)")
			fmt.Println("Software\tSoftware name")
			fmt.Println("Version\t\tSoftware version")
			os.Exit(0)
		}
	}
	if *fields == "" {
		fieldsToPrint = strings.Split("Cve,CveDesc,Cwe,CweDesc,Exploit,Refs,Cvssv2,Cvssv3,Software,Version", ",")
	}
	if *write != "" {
		if _, err := os.Stat(*write); err == nil {
			fmt.Println("This file exists")
			os.Exit(1)
		}
	}
}

func validateFields() []string {
	var out []string
	checkArray := strings.Split(*fields, ",")
	for _, toCheck := range checkArray {
		for _, allowed := range AllowedFields {
			if allowed == toCheck {
				out = append(out, toCheck)
			}
		}
	}
	return out
}

func validateCve() []string {
	var out []string
	for _, cves := range strings.Split(*cve, ",") {
		cveRegexp := regexp.MustCompile("[0-9]+")
		regexpArray := cveRegexp.FindAllString(cves, -1)
		cves = strings.Join(regexpArray, "")
		if len(cves) < 5 {
			fmt.Println("Please, insert at least year (YYYY) and ID number")
			Usage()
			os.Exit(71)
		}
		id := cves[4:]
		cves := strings.Join([]string{"CVE", cves[0:4], id}, "-")
		out = append(out, cves)
	}
	return out
}

func printResults(resArray []db.Results, fields []string) {
	const padding = 2
	w := tabwriter.NewWriter(os.Stdout, 0, 0, padding, ' ', tabwriter.Debug)
	if *header {
		for _, f := range fields {
			fmt.Fprint(w, f, "\t")
		}
	}
	w.Flush()
	for i, res := range resArray {
		r := reflect.ValueOf(res)
		for _, f := range fields {
			fmt.Fprint(w, reflect.Indirect(r).FieldByName(f), "\t")
		}
		if i != 0 {
			fmt.Println()
		}
		w.Flush()
	}
}

func writeCsv(resArray []db.Results) {
	if *write != "" {
		csvout, err := csv.Marshal(resArray)
		if err != nil {
			fmt.Println("Error durin marshalling [", err, "]")
		}
		//fmt.Println(string(*write))
		errWrite := ioutil.WriteFile(*write, csvout, 0644)
		if errWrite != nil {
			fmt.Println("Error during writing to file [", err, "]")
		}
	}
}

/************************
*		MAIN FUNCTION		*
************************/

func main() {
	var (
		resArray []db.Results
		res      db.Results
		count    int = 0
		//sw2Search []string
	)
	Init()
	if *cve != "" {
		cve := validateCve()
		for _, c := range cve {
			i := 0
			res, i = db.CveSearch(c)
			if i != 0 {
				resArray = append(resArray, res)
				count += i
			}
		}
	}
	if *sw != "" {
		if *swVersion == "" {
			for _, singleSw := range strings.Split(*sw, ",") {
				tmp := db.SwSearch(singleSw)
				for _, element := range tmp {
					resArray = append(resArray, element)
				}
			}
		}
		if *swVersion != "" {
			resArray = db.SwVSearch(*sw, *swVersion)
		}
	}
	writeCsv(resArray)
	printResults(resArray, fieldsToPrint)
}
